---
# Jellyfin Media Server Helm Chart

enabled: false

replicaCount: 1

image:
  repository: linuxserver/jellyfin
  pullPolicy: IfNotPresent
  tag: "10.11.6"

imagePullSecrets: []
nameOverride: ""
fullnameOverride: ""

serviceAccount:
  create: true
  automount: true
  annotations: {}
  name: ""

podAnnotations: {}
podLabels: {}

podSecurityContext: {}
securityContext: {}

# GPU Configuration for hardware transcoding
gpu:
  enabled: false
  runtimeClass: nvidia
  count: 1

env: []
envFrom: []

service:
  type: ClusterIP
  port: 8096

ingress:
  enabled: false
  className: ""
  annotations: {}
  hosts: []
  tls: []

cfTunnel:
  enabled: false
  tunnelRef: {}
  subjects: []

resources: {}

# OpenBao (Vault) integration for secrets management
openbao:
  # Enable OpenBao integration
  enabled: false

  # VaultConnection reference (usually in vault-secrets-operator-system namespace)
  vaultConnectionRef: "vault-secrets-operator-system/default"

  # VaultAuth configuration
  vaultAuth:
    # Create VaultAuth resource for this chart
    create: true
    # Kubernetes auth method mount point in OpenBao
    mount: "kubernetes"
    # OpenBao role name for this namespace
    role: "media"
    # Token expiration in seconds
    tokenExpirationSeconds: 600

  # Static secret configuration (for API keys, passwords, etc.)
  staticSecret:
    # Enable static secret from KV store
    enabled: false
    # KV v2 mount path
    mount: "secret"
    # Path to secret within mount (e.g., "media/jellyfin/credentials")
    path: ""
    # Name of the Kubernetes secret to create (defaults to <release>-vault-secret)
    secretName: ""
    # Refresh interval
    refreshAfter: "1h"
    # Restart deployment when secret changes
    rolloutRestartTargets: []
    # - kind: Deployment
    #   name: jellyfin

autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 100
  targetCPUUtilizationPercentage: 80
  # targetMemoryUtilizationPercentage: 80

# Vertical Pod Autoscaling
vpa:
  enabled: true
  updateMode: "Auto"
  # ControlledResources defaults to ["cpu", "memory"] if not specified
  # controlledResources: ["cpu", "memory"]
  # resourcePolicy:
  #   containerPolicies:
  #     - containerName: '*'
  #       minAllowed:
  #         cpu: 100m
  #         memory: 256Mi
  #       maxAllowed:
  #         cpu: 4
  #         memory: 16Gi
  #       controlledValues: RequestsAndLimits

# SSO Plugin Configuration
# Configures the Jellyfin SSO plugin to use OIDC authentication (e.g., Keycloak)
sso:
  # Enable SSO configuration via init container
  enabled: false
  # OIDC Provider name (appears on login button)
  providerName: "Discord"
  # OIDC endpoint (e.g., Keycloak realm URL)
  oidcEndpoint: ""
  # OIDC client ID
  clientId: ""
  # OIDC client secret
  clientSecret: ""
  # Canonical URL for Jellyfin (public URL)
  canonicalUrl: ""
  # Disable Pushed Authorization Request (PAR) - required for some providers
  disablePAR: true
  # UID/GID for file ownership (linuxserver images use 1000:100)
  uid: 1000
  gid: 100

volumes: []
volumeMounts: []

nodeSelector: {}
tolerations: []
affinity: {}

# Deployment strategy - use Recreate for RWO volumes
strategy:
  type: Recreate

# Database Optimization Configuration
# Runs SQLite optimizations via an init container before Jellyfin starts
# Creates a backup before optimization and restores on failure
optimization:
  enabled: false
  sqlite:
    # Enable SQLite optimization init container
    enabled: true
    # Run PRAGMA optimize and ANALYZE (recommended)
    # PRAGMA optimize runs the query planner optimization
    # ANALYZE updates index statistics for better query planning
    runOptimize: true
    # Ensure WAL journal mode is enabled (recommended, already Jellyfin default)
    # WAL mode allows concurrent reads/writes for better multi-user performance
    enableWAL: true
    # Run REINDEX to rebuild all indexes (helps with index fragmentation)
    # Recommended to run periodically, especially after large library changes
    runReindex: false
    # Run VACUUM to compact database and defragment
    # Can be slow on large databases (700MB+ may take several minutes)
    # Consider running this only occasionally, not on every restart
    runVacuum: false
    # Enable incremental auto-vacuum mode (persists in database)
    # Allows gradual space reclamation without full VACUUM overhead
    enableAutoVacuum: true
    # Run incremental vacuum to reclaim free pages
    # Lighter alternative to full VACUUM, reclaims ~1000 pages per run
    runIncrementalVacuum: true
    # Checkpoint and truncate WAL file to reclaim disk space
    # Prevents WAL file from growing indefinitely
    truncateWAL: true
    # Number of backups to retain
    backupRetention: 3
    # Path to config volume mount (where jellyfin.db is located)
    configPath: /config
    # Database path relative to config (linuxserver images use data/data/)
    dbPath: data/data/jellyfin.db
    # Backup directory (relative to configPath)
    backupDir: data/backups/sqlite-optimization
    # Init container image
    image:
      repository: alpine
      tag: "3"
      pullPolicy: IfNotPresent
    # Resource limits for init container
    resources:
      limits:
        cpu: 500m
        memory: 256Mi
      requests:
        cpu: 100m
        memory: 64Mi
